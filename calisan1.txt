#include <iostream>
#include <string>
#include <curl/curl.h>
#include <libsecret/secret.h>

using namespace std;

static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
    ((string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

// Gnome Keyring'den token oku
string get_token_from_keyring(const string& owner) {
    GError* error = nullptr;

    const SecretSchema schema = {
        "org.gitee.cli.Token", SECRET_SCHEMA_NONE,
        {
            { "owner", SECRET_SCHEMA_ATTRIBUTE_STRING },
            { nullptr, SECRET_SCHEMA_ATTRIBUTE_STRING }
        }
    };

    gchar* token = secret_password_lookup_sync(&schema, nullptr, &error,
                                              "owner", owner.c_str(),
                                              nullptr);
    if (error != nullptr) {
        cerr << "Keyring error: " << error->message << endl;
        g_error_free(error);
        return "";
    }
    if (!token) {
        cerr << "Token bulunamadi." << endl;
        return "";
    }
    string token_str(token);
    secret_password_free(token);
    return token_str;
}

// Gnome Keyring'e token kaydet
bool store_token_to_keyring(const string& owner, const string& token) {
    GError* error = nullptr;

    const SecretSchema schema = {
        "org.gitee.cli.Token", SECRET_SCHEMA_NONE,
        {
            { "owner", SECRET_SCHEMA_ATTRIBUTE_STRING },
            { nullptr, SECRET_SCHEMA_ATTRIBUTE_STRING }
        }
    };

    secret_password_store_sync(&schema, nullptr, "Gitee CLI Token",
                              token.c_str(), nullptr,
                              &error, "owner", owner.c_str(), nullptr);
    if (error != nullptr) {
        cerr << "Keyring error: " << error->message << endl;
        g_error_free(error);
        return false;
    }
    return true;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        cout << "Kullanım:\n"
             << "  ./gitee-cli store <owner> <token>  # Token'i kaydet\n"
             << "  ./gitee-cli create-issue <owner> <repo> <title> <body>  # Issue oluştur\n";
        return 1;
    }

    string command = argv[1];

    if (command == "store") {
        if (argc != 4) {
            cerr << "Kullanım: ./gitee-cli store <owner> <token>" << endl;
            return 1;
        }
        string owner = argv[2];
        string token = argv[3];
        if (store_token_to_keyring(owner, token)) {
            cout << "Token kaydedildi." << endl;
        } else {
            cerr << "Token kaydedilemedi." << endl;
        }
        return 0;
    }
    else if (command == "create-issue") {
        if (argc != 6) {
            cerr << "Kullanım: ./gitee-cli create-issue <owner> <repo> <title> <body>" << endl;
            return 1;
        }

        string owner = argv[2];
        string repo = argv[3];
        string title = argv[4];
        string body = argv[5];

        string token = get_token_from_keyring(owner);
        if (token.empty()) {
            cerr << "Token veritabanından okunamadı!" << endl;
            return 1;
        }

        CURL* curl = curl_easy_init();
        if (!curl) {
            cerr << "curl başlatılamadı!" << endl;
            return 1;
        }

        string url = "https://gitee.com/api/v5/repos/" + owner + "/issues";

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_POST, 1L);

        // form data oluştur
        char* title_escaped = curl_easy_escape(curl, title.c_str(), 0);
        char* body_escaped = curl_easy_escape(curl, body.c_str(), 0);
        char* repo_escaped = curl_easy_escape(curl, repo.c_str(), 0);
        char* token_escaped = curl_easy_escape(curl, token.c_str(), 0);

        string post_fields = "access_token=" + string(token_escaped) + 
                             "&repo=" + string(repo_escaped) + 
                             "&title=" + string(title_escaped) + 
                             "&body=" + string(body_escaped);

        curl_free(title_escaped);
        curl_free(body_escaped);
        curl_free(repo_escaped);
        curl_free(token_escaped);

        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_fields.c_str());

        string response;
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);

        CURLcode res = curl_easy_perform(curl);

        if (res != CURLE_OK) {
            cerr << "curl hatası: " << curl_easy_strerror(res) << endl;
            curl_easy_cleanup(curl);
            return 1;
        }

        long http_code = 0;
        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
        cout << "HTTP kodu: " << http_code << endl;
        cout << "API cevabı: " << response << endl;

        if (http_code == 201) {
            cout << "Issue başarıyla oluşturuldu." << endl;
        } else {
            cerr << "Issue oluşturulamadı." << endl;
        }

        curl_easy_cleanup(curl);
        return 0;
    }

    cerr << "Bilinmeyen komut: " << command << endl;
    return 1;
}

