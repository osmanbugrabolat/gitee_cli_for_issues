#include <iostream>
#include <string>
#include <curl/curl.h>
#include <libsecret/secret.h>

using namespace std;

static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
    ((string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

// Gnome Keyring'den token oku
string get_token_from_keyring(const string& owner) {
    GError* error = nullptr;
    const SecretSchema schema = {
        "org.gitee.cli.Token", SECRET_SCHEMA_NONE,
        {
            { "owner", SECRET_SCHEMA_ATTRIBUTE_STRING },
            { nullptr, SECRET_SCHEMA_ATTRIBUTE_STRING }
        }
    };
    gchar* token = secret_password_lookup_sync(&schema, nullptr, &error, "owner", owner.c_str(), nullptr);
    if (error != nullptr) {
        cerr << "Keyring error: " << error->message << endl;
        g_error_free(error);
        return "";
    }
    if (!token) {
        cerr << "Token bulunamadi." << endl;
        return "";
    }
    string token_str(token);
    secret_password_free(token);
    return token_str;
}

// Token kaydet
bool store_token_to_keyring(const string& owner, const string& token) {
    GError* error = nullptr;
    const SecretSchema schema = {
        "org.gitee.cli.Token", SECRET_SCHEMA_NONE,
        {
            { "owner", SECRET_SCHEMA_ATTRIBUTE_STRING },
            { nullptr, SECRET_SCHEMA_ATTRIBUTE_STRING }
        }
    };
    secret_password_store_sync(&schema, nullptr, "Gitee CLI Token", token.c_str(), nullptr, &error,
                               "owner", owner.c_str(), nullptr);
    if (error != nullptr) {
        cerr << "Keyring error: " << error->message << endl;
        g_error_free(error);
        return false;
    }
    return true;
}

// Ortak HTTP gönderici
bool send_request(CURL* curl, const string& url, const string& method, const string& post_fields,
                  string& response, long& http_code) {
    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
    if (method == "POST") {
        curl_easy_setopt(curl, CURLOPT_POST, 1L);
    } else if (method == "PATCH") {
        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "PATCH");
    } else {
        cerr << "Desteklenmeyen method: " << method << endl;
        return false;
    }
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_fields.c_str());
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
    CURLcode res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        cerr << "curl hatası: " << curl_easy_strerror(res) << endl;
        return false;
    }
    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
    return true;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        cout << "Kullanım:\n"
             << "  ./gitee-cli store <owner> <token>\n"
             << "  ./gitee-cli create-issue <owner> <repo> <title> <body> <issue_type>\n"
             << "  ./gitee-cli update-issue <owner> <repo> <number> [title] [body] [state]\n";
        return 1;
    }

    string command = argv[1];

    if (command == "store") {
        if (argc != 4) {
            cerr << "Kullanım: ./gitee-cli store <owner> <token>" << endl;
            return 1;
        }
        string owner = argv[2];
        string token = argv[3];
        if (store_token_to_keyring(owner, token)) {
            cout << "Token kaydedildi." << endl;
        } else {
            cerr << "Token kaydedilemedi." << endl;
        }
        return 0;
    }

    else if (command == "create-issue") {
        if (argc != 7) {
            cerr << "Kullanım: ./gitee-cli create-issue <owner> <repo> <title> <body> <issue_type>" << endl;
            return 1;
        }
        string owner = argv[2], repo = argv[3], title = argv[4], body = argv[5], issue_type = argv[6];
        string token = get_token_from_keyring(owner);
        if (token.empty()) return 1;

        CURL* curl = curl_easy_init();
        if (!curl) return 1;

        string url = "https://gitee.com/api/v5/repos/" + owner + "/issues";

        char* title_e = curl_easy_escape(curl, title.c_str(), 0);
        char* body_e = curl_easy_escape(curl, body.c_str(), 0);
        char* token_e = curl_easy_escape(curl, token.c_str(), 0);
        char* repo_e = curl_easy_escape(curl, repo.c_str(), 0);
        char* type_e = curl_easy_escape(curl, issue_type.c_str(), 0);

        string post = "access_token=" + string(token_e) + "&repo=" + string(repo_e)
                    + "&title=" + string(title_e) + "&body=" + string(body_e)
                    + "&issue_type=" + string(type_e);

        string response;
        long http_code;
        bool ok = send_request(curl, url, "POST", post, response, http_code);

        cout << "HTTP kodu: " << http_code << endl;
        cout << "Yanıt: " << response << endl;

        if (ok && http_code == 201)
            cout << "Issue oluşturuldu." << endl;
        else
            cerr << "Issue oluşturulamadı." << endl;

        curl_free(title_e); curl_free(body_e); curl_free(token_e); curl_free(repo_e); curl_free(type_e);
        curl_easy_cleanup(curl);
        return ok ? 0 : 1;
    }

    else if (command == "update-issue") {
        if (argc < 5) {
            cerr << "Kullanım: ./gitee-cli update-issue <owner> <repo> <number> [title] [body] [state]" << endl;
            return 1;
        }

        string owner = argv[2], repo = argv[3], number = argv[4];
        string title = (argc > 5) ? argv[5] : "";
        string body  = (argc > 6) ? argv[6] : "";
        string state = (argc > 7) ? argv[7] : "";

        string token = get_token_from_keyring(owner);
        if (token.empty()) return 1;

        CURL* curl = curl_easy_init();
        if (!curl) return 1;

        string url = "https://gitee.com/api/v5/repos/" + owner + "/issues/" + number;

        char* token_e = curl_easy_escape(curl, token.c_str(), 0);
        char* repo_e  = curl_easy_escape(curl, repo.c_str(), 0);

        string post = "access_token=" + string(token_e) + "&repo=" + string(repo_e);

        if (!title.empty()) {
            char* e = curl_easy_escape(curl, title.c_str(), 0);
            post += "&title=" + string(e);
            curl_free(e);
        }
        if (!body.empty()) {
            char* e = curl_easy_escape(curl, body.c_str(), 0);
            post += "&body=" + string(e);
            curl_free(e);
        }
        if (!state.empty()) {
            char* e = curl_easy_escape(curl, state.c_str(), 0);
            post += "&state=" + string(e);
            curl_free(e);
        }

        string response;
        long http_code;
        bool ok = send_request(curl, url, "PATCH", post, response, http_code);

        cout << "HTTP kodu: " << http_code << endl;
        cout << "Yanıt: " << response << endl;

        if (ok && http_code == 200)
            cout << "Issue güncellendi." << endl;
        else
            cerr << "Issue güncellenemedi." << endl;

        curl_free(token_e); curl_free(repo_e);
        curl_easy_cleanup(curl);
        return ok ? 0 : 1;
    }

    cerr << "Bilinmeyen komut: " << command << endl;
    return 1;
}

